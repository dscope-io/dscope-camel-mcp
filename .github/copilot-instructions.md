# Camel MCP Component - AI Coding Instructions

## Architecture Overview

This is an Apache Camel 4 component (v1.3.0) that implements the Model Context Protocol (MCP) for AI agent integration. The component follows Camel's standard plugin architecture and supports both **producer** (client) and **consumer** (server) modes.

- **Component Registration**: `src/main/resources/META-INF/services/org/apache/camel/component/mcp` registers `McpComponent`
- **Protocol Flow**: Routes can act as MCP clients (`to("mcp:...")`) sending JSON-RPC 2.0 requests, or as MCP servers (`from("mcp:...")`) receiving and processing them
- **Transport**: HTTP and WebSocket via Camel Undertow

### Key Files to Understand
- `McpComponent.java` - Entry point, creates endpoints from URIs like `mcp:http://localhost:8080/mcp?method=initialize`
- `McpEndpoint.java` - `@UriEndpoint(scheme="mcp", category=Category.AI)`, creates producer/consumer, delegates config to `McpConfiguration`
- `McpConfiguration.java` - `@UriPath`/`@UriParam` annotated configuration (uri, method, websocket, etc.)
- `McpProducer.java` - Handles outbound MCP requests, wraps payloads in JSON-RPC format
- `McpConsumer.java` - Fully implemented inbound MCP server wrapping Undertow with processor pipeline: SizeGuard → HttpValidator → RateLimit → JsonRpcEnvelope → user processor → JSON serialization
- `processor/` - 20+ built-in processors for JSON-RPC, tools, resources, UI Bridge, health, streaming, and notifications
- `catalog/` - `McpMethodCatalog` (tool definitions from `methods.yaml`) and `McpResourceCatalog` (resource definitions from `resources.yaml`)
- `service/` - `McpUiSessionRegistry` (session lifecycle, 1h TTL) and `McpWebSocketNotifier` (WebSocket notifications)
- `model/` - Jackson POJOs: requests, responses, resources, UI sessions, notifications
- `tools/karavan/McpKaravanMetadataGenerator.java` - Generates Apache Karavan visual designer metadata

### Generated Artifacts
- `src/generated/` - Auto-generated by `camel-package-maven-plugin`: component JSON descriptor (`mcp.json`), `McpEndpointConfigurer`, `McpComponentConfigurer`, `McpEndpointUriFactory`
- `src/main/resources/karavan/metadata/` - Karavan metadata: component descriptor, method catalog, kamelet descriptors, labels
- `src/main/docs/mcp-component.adoc` - AsciiDoc component docs with auto-updated option tables

## Development Workflows

### Building & Testing
```bash
# Requires Java 21+
mvn clean install                                            # Build + run 87 tests
mvn exec:java -Dexec.mainClass=org.apache.camel.main.Main   # Run example route
mvn -Pkaravan-metadata compile exec:java                     # Regenerate Karavan metadata
```

Use VS Code tasks: "Build with Maven" and "Run Camel MCP" for convenience. Both commands rely on Camel's YAML DSL loader, so keep `camel-yaml-dsl` on the classpath.

### Testing Pattern
Tests load YAML routes via `Main.configure().setRoutesIncludePattern(...)` (see `McpComponentTest.java`) to compose a mock server plus client route:
- `mock-mcp-server.yaml` exposes `POST /mcp` and conditionally returns canned MCP responses
- `example-mcp.yaml` triggers the component once via a `timer://` source and logs the JSON-RPC reply
Integration-style assertions are done on raw HTTP responses; spin up both routes when reproducing tests locally.

The YAML DSL examples set JSON strings with `setBody.constant` and immediately `unmarshal.json` to build the Map payload the producer expects—mirror that pattern when adding new scenarios.

### Sample Projects
- `samples/mcp-service/` - Full-featured MCP server with Kamelets/YAML routes (port 8080/8090)
- `samples/mcp-consumer/` - Minimal MCP server using direct `from("mcp:...")` consumer (port 3000/3001)

## Component Conventions

### URI Format

**Producer (Client):**
```
mcp:targetUri?method=mcpMethod
```

**Consumer (Server):**
```
mcp:http://host:port/path              # HTTP server
mcp:http://host:port/path?websocket=true   # WebSocket server
```

### Producer Message Flow
1. Incoming exchange body must be a `Map` that becomes the JSON-RPC `params`; null produces an empty payload
2. Producer injects `jsonrpc: "2.0"`, random UUID `id`, and the configured `method`
3. Body is serialized with Jackson and sent using `ProducerTemplate.requestBody(...)` to the target URI
4. Response JSON is parsed into `McpResponse` and set on the OUT message; callers should extract `getResult()`

### Consumer Message Flow
1. Undertow server receives HTTP POST or WebSocket message
2. `McpRequestSizeGuardProcessor` validates request size
3. `McpHttpValidatorProcessor` validates headers (HTTP only; checks Accept includes `application/json` + `text/event-stream`)
4. `McpRateLimitProcessor` applies rate limiting
5. `McpJsonRpcEnvelopeProcessor` parses JSON-RPC, sets exchange properties: `mcp.jsonrpc.method`, `mcp.jsonrpc.id`, `mcp.jsonrpc.type`, `mcp.tool.name`
6. User processor handles the request and sets the response body
7. Response is serialized to JSON with `application/json` content type

### Configuration Pattern
`McpConfiguration` uses Camel's `@UriPath` and `@UriParam` annotations for automatic parameter binding from route URIs. `McpEndpoint` duplicates these as delegate fields for the `camel-package-maven-plugin` to generate proper metadata. Validate new query parameters in `McpConfiguration` so Camel tooling (autocompletion/docs) stays accurate.

## Key Dependencies & Integration

- **Jackson** for JSON serialization of MCP protocol messages (default `ObjectMapper`, no custom modules yet)
- **camel-http/HTTP URIs** for the synchronous producer transport; this component piggybacks on whatever Camel endpoint backs the target URI
- **camel-main** to bootstrap routes for tests and samples (YAML loader is configured through `RoutesIncludePattern`)
- **camel-yaml-dsl** so Camel can parse the YAML route definitions that drive the tests
- **camel-undertow** for consumer-side HTTP/WebSocket server endpoints
- **camel-package-maven-plugin** generates component JSON descriptor and configurers from `@UriEndpoint` annotations
- **logback-classic** (test scope) provides the SLF4J backend during Maven Surefire runs

## Publishing & Deployment

Project is configured for Maven Central publication via GitHub Actions:
- Tag format: `v1.0.0` triggers automatic release
- GPG signing and Sonatype OSSRH integration configured
- See `docs/PUBLISH_GUIDE.md` for complete deployment setup

## Extending the Component

- Add method presets by constraining `McpConfiguration.setMethod` (e.g., validate enums or expose fluent options)
- Expand request metadata via `McpRequest` if MCP spec evolves; adjust serialization in `McpProducer`
- Add new processors by extending `AbstractMcpResponseProcessor` and registering with `@BindToRegistry`
- When adding fields to responses, update the model POJOs and the mock route payloads so tests keep passing
- Add new protocol hooks by extending the YAML route examples—e.g. create payloads in `example-mcp.yaml` and define matching canned responses in `mock-mcp-server.yaml`
- After adding new MCP methods or properties, regenerate Karavan metadata: `mvn -Pkaravan-metadata compile exec:java`
- Add new `@UriParam` fields to `McpConfiguration` (and delegate in `McpEndpoint`) then rebuild to update the generated component descriptor